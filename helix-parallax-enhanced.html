<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Helix with Parallax Mapping</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
        }
        .control-group {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 150px;
        }
        input[type="range"] {
            width: 150px;
        }
        select {
            width: 150px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Helix with Parallax Mapping</h3>
        <div>FPS: <span id="fps">0</span></div>
        <div>Vertices: <span id="vertices">0</span></div>
        <div>Triangles: <span id="triangles">0</span></div>
    </div>
    
    <div id="controls">
        <h3>Controls</h3>
        <div class="control-group">
            <label>Parallax Scale:</label>
            <input type="range" id="parallaxScale" min="0" max="0.2" step="0.01" value="0.1">
            <span id="parallaxScaleValue">0.1</span>
        </div>
        <div class="control-group">
            <label>Min Layers:</label>
            <input type="range" id="minLayers" min="2" max="32" step="1" value="8">
            <span id="minLayersValue">8</span>
        </div>
        <div class="control-group">
            <label>Max Layers:</label>
            <input type="range" id="maxLayers" min="8" max="128" step="1" value="32">
            <span id="maxLayersValue">32</span>
        </div>
        <div class="control-group">
            <label>Helix Radius:</label>
            <input type="range" id="helixRadius" min="1" max="5" step="0.1" value="2">
            <span id="helixRadiusValue">2</span>
        </div>
        <div class="control-group">
            <label>Helix Height:</label>
            <input type="range" id="helixHeight" min="2" max="10" step="0.1" value="5">
            <span id="helixHeightValue">5</span>
        </div>
        <div class="control-group">
            <label>Texture:</label>
            <select id="textureSelect">
                <option value="rock">Rock</option>
                <option value="brick">Brick</option>
                <option value="metal">Metal</option>
            </select>
        </div>
        <div class="control-group">
            <label>Wireframe:</label>
            <input type="checkbox" id="wireframe">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 10, 50);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // Stats
        const stats = new Stats();
        stats.showPanel(0);
        document.body.appendChild(stats.dom);
        stats.dom.style.left = '10px';
        stats.dom.style.top = '120px';
        
        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0x4488ff, 0.5, 20);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);
        
        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            rock: {
                albedo: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                height: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                normal: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='
            }
        };
        
        // Create helix geometry
        function createHelixGeometry(radius, height, segments, radialSegments) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            
            const turns = 3; // Number of complete turns
            const angleStep = (Math.PI * 2 * turns) / segments;
            const heightStep = height / segments;
            const tubeRadius = 0.3;
            
            // Generate vertices
            for (let i = 0; i <= segments; i++) {
                const angle = i * angleStep;
                const y = i * heightStep - height / 2;
                const centerX = Math.cos(angle) * radius;
                const centerZ = Math.sin(angle) * radius;
                
                for (let j = 0; j <= radialSegments; j++) {
                    const radialAngle = (j / radialSegments) * Math.PI * 2;
                    
                    // Calculate tangent to the helix
                    const tangentX = -Math.sin(angle);
                    const tangentY = heightStep / angleStep;
                    const tangentZ = Math.cos(angle);
                    
                    // Normalize tangent
                    const tangentLength = Math.sqrt(tangentX * tangentX + tangentY * tangentY + tangentZ * tangentZ);
                    const tX = tangentX / tangentLength;
                    const tY = tangentY / tangentLength;
                    const tZ = tangentZ / tangentLength;
                    
                    // Calculate normal (perpendicular to tangent)
                    const nX = Math.cos(radialAngle) * Math.cos(angle);
                    const nY = Math.sin(radialAngle);
                    const nZ = Math.cos(radialAngle) * Math.sin(angle);
                    
                    // Vertex position
                    const x = centerX + nX * tubeRadius;
                    const y2 = y + nY * tubeRadius;
                    const z = centerZ + nZ * tubeRadius;
                    
                    vertices.push(x, y2, z);
                    normals.push(nX, nY, nZ);
                    uvs.push(i / segments * 3, j / radialSegments);
                }
            }
            
            // Generate indices
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < radialSegments; j++) {
                    const a = i * (radialSegments + 1) + j;
                    const b = a + radialSegments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            
            return geometry;
        }
        
        // Parallax shader material
        const parallaxVertexShader = `
            varying vec2 vUv;
            varying vec3 vViewPosition;
            varying vec3 vNormal;
            varying vec3 vTangent;
            varying vec3 vBitangent;
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                
                // Calculate tangent and bitangent
                vec3 objectTangent = vec3(1.0, 0.0, 0.0);
                vec3 transformedTangent = normalize(normalMatrix * objectTangent);
                vTangent = transformedTangent;
                vBitangent = normalize(cross(vNormal, vTangent));
                
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        const parallaxFragmentShader = `
            uniform sampler2D albedoMap;
            uniform sampler2D heightMap;
            uniform sampler2D normalMap;
            uniform float parallaxScale;
            uniform float minLayers;
            uniform float maxLayers;
            uniform vec3 lightPosition;
            
            varying vec2 vUv;
            varying vec3 vViewPosition;
            varying vec3 vNormal;
            varying vec3 vTangent;
            varying vec3 vBitangent;
            
            vec2 parallaxMapping(vec2 texCoords, vec3 viewDir) {
                float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));
                float layerDepth = 1.0 / numLayers;
                float currentLayerDepth = 0.0;
                
                vec2 P = viewDir.xy * parallaxScale;
                vec2 deltaTexCoords = P / numLayers;
                
                vec2 currentTexCoords = texCoords;
                float currentDepthMapValue = texture2D(heightMap, currentTexCoords).r;
                
                while(currentLayerDepth < currentDepthMapValue) {
                    currentTexCoords -= deltaTexCoords;
                    currentDepthMapValue = texture2D(heightMap, currentTexCoords).r;
                    currentLayerDepth += layerDepth;
                }
                
                // Parallax occlusion mapping refinement
                vec2 prevTexCoords = currentTexCoords + deltaTexCoords;
                float afterDepth = currentDepthMapValue - currentLayerDepth;
                float beforeDepth = texture2D(heightMap, prevTexCoords).r - currentLayerDepth + layerDepth;
                
                float weight = afterDepth / (afterDepth - beforeDepth);
                vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);
                
                return finalTexCoords;
            }
            
            void main() {
                // Transform view direction to tangent space
                mat3 TBN = mat3(vTangent, vBitangent, vNormal);
                vec3 viewDir = normalize(transpose(TBN) * vViewPosition);
                
                // Apply parallax mapping
                vec2 texCoords = parallaxMapping(vUv, viewDir);
                
                // Sample textures with parallax-adjusted coordinates
                vec3 albedo = texture2D(albedoMap, texCoords).rgb;
                vec3 normal = texture2D(normalMap, texCoords).rgb;
                normal = normalize(normal * 2.0 - 1.0);
                
                // Transform normal from tangent space to view space
                normal = TBN * normal;
                
                // Basic lighting
                vec3 lightDir = normalize(lightPosition - vViewPosition);
                float diff = max(dot(normal, lightDir), 0.0);
                
                vec3 ambient = albedo * 0.3;
                vec3 diffuse = albedo * diff * 0.7;
                
                gl_FragColor = vec4(ambient + diffuse, 1.0);
            }
        `;
        
        // Create materials
        let helixMaterial;
        let helixMesh;
        
        function createHelix() {
            const radius = parseFloat(document.getElementById('helixRadius').value);
            const height = parseFloat(document.getElementById('helixHeight').value);
            
            if (helixMesh) {
                scene.remove(helixMesh);
                helixMesh.geometry.dispose();
            }
            
            const geometry = createHelixGeometry(radius, height, 200, 32);
            
            // Create a simple colored texture as placeholder
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Create rocky texture
            ctx.fillStyle = '#555';
            ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgb(${80 + Math.random() * 40}, ${70 + Math.random() * 40}, ${60 + Math.random() * 40})`;
                ctx.fillRect(Math.random() * 256, Math.random() * 256, 10 + Math.random() * 20, 10 + Math.random() * 20);
            }
            const rockTexture = new THREE.CanvasTexture(canvas);
            
            // Create height map
            const heightCanvas = document.createElement('canvas');
            heightCanvas.width = 256;
            heightCanvas.height = 256;
            const heightCtx = heightCanvas.getContext('2d');
            
            // Create noise pattern for height
            const imageData = heightCtx.createImageData(256, 256);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const value = Math.random() * 128 + 64;
                imageData.data[i] = value;
                imageData.data[i + 1] = value;
                imageData.data[i + 2] = value;
                imageData.data[i + 3] = 255;
            }
            heightCtx.putImageData(imageData, 0, 0);
            const heightTexture = new THREE.CanvasTexture(heightCanvas);
            
            // Create normal map (blue-ish)
            const normalCanvas = document.createElement('canvas');
            normalCanvas.width = 256;
            normalCanvas.height = 256;
            const normalCtx = normalCanvas.getContext('2d');
            normalCtx.fillStyle = '#8080ff';
            normalCtx.fillRect(0, 0, 256, 256);
            const normalTexture = new THREE.CanvasTexture(normalCanvas);
            
            helixMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    albedoMap: { value: rockTexture },
                    heightMap: { value: heightTexture },
                    normalMap: { value: normalTexture },
                    parallaxScale: { value: parseFloat(document.getElementById('parallaxScale').value) },
                    minLayers: { value: parseFloat(document.getElementById('minLayers').value) },
                    maxLayers: { value: parseFloat(document.getElementById('maxLayers').value) },
                    lightPosition: { value: directionalLight.position }
                },
                vertexShader: parallaxVertexShader,
                fragmentShader: parallaxFragmentShader,
                side: THREE.DoubleSide
            });
            
            helixMesh = new THREE.Mesh(geometry, helixMaterial);
            helixMesh.castShadow = true;
            helixMesh.receiveShadow = true;
            scene.add(helixMesh);
            
            // Update info
            document.getElementById('vertices').textContent = geometry.attributes.position.count;
            document.getElementById('triangles').textContent = geometry.index.count / 3;
        }
        
        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -3;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Create initial helix
        createHelix();
        
        // UI Controls
        document.getElementById('parallaxScale').addEventListener('input', (e) => {
            document.getElementById('parallaxScaleValue').textContent = e.target.value;
            if (helixMaterial) {
                helixMaterial.uniforms.parallaxScale.value = parseFloat(e.target.value);
            }
        });
        
        document.getElementById('minLayers').addEventListener('input', (e) => {
            document.getElementById('minLayersValue').textContent = e.target.value;
            if (helixMaterial) {
                helixMaterial.uniforms.minLayers.value = parseFloat(e.target.value);
            }
        });
        
        document.getElementById('maxLayers').addEventListener('input', (e) => {
            document.getElementById('maxLayersValue').textContent = e.target.value;
            if (helixMaterial) {
                helixMaterial.uniforms.maxLayers.value = parseFloat(e.target.value);
            }
        });
        
        document.getElementById('helixRadius').addEventListener('input', (e) => {
            document.getElementById('helixRadiusValue').textContent = e.target.value;
            createHelix();
        });
        
        document.getElementById('helixHeight').addEventListener('input', (e) => {
            document.getElementById('helixHeightValue').textContent = e.target.value;
            createHelix();
        });
        
        document.getElementById('wireframe').addEventListener('change', (e) => {
            if (helixMaterial) {
                helixMaterial.wireframe = e.target.checked;
            }
        });
        
        // Animation loop
        let frameCount = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            stats.begin();
            
            if (helixMesh) {
                helixMesh.rotation.y += 0.005;
            }
            
            pointLight.position.x = Math.sin(Date.now() * 0.001) * 3;
            pointLight.position.z = Math.cos(Date.now() * 0.001) * 3;
            
            controls.update();
            renderer.render(scene, camera);
            
            stats.end();
            
            // Update FPS display
            frameCount++;
            if (frameCount % 20 === 0) {
                document.getElementById('fps').textContent = Math.round(stats.getFPS());
            }
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>